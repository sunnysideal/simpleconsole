/*
Simple Console (c) 2021 Alan Paton

A simple weather display console WeeWX template

Reads all config and data from JSON files generated by WeeWX.
There is no WeeWX skin/template output in any files other than the JSON data.

This console relies on a MQTT broker, it will not work without it.

*/ 
 
// Initial required data
 
// properties for the wind needle
var needle = {
  base: 15,
  height: 33,
  degrees: 0,
  targetDegrees: 0,
  targetCardinal: "---",
  windSpeed: 0,
  moving: 0,
  direction: 1,
  speed: 3,
  bfDesc: ""
}

var config = {
	latitude:0,
	longitude:0,
	owmkey:0,
	consoleunits:0,
	forecastGap:2
}

//load scripts in order
loadScript('js/suncalc.js') // solar data library
    .then(() => loadScript('js/paho-mqtt-min.js')) // mqtt library
    .then(() => startConnect()) // start connection to mqtt broker
	.then(() => loadJSON("js/config.json",loadConfig)) // load config from JSON
    .then(() => loadJSON("js/data.json", updateData ))  // load weewx current data
    .catch(() => console.error('Something went wrong.'))

function loadConfig(text){ // get config from JSON
  data = JSON.parse(text);

  config.latitude = ConvertDMToDD(Number(data.config.latitude_deg),Number(data.config.latitude_minutes),data.config.latitude_heading);
  config.longitude = ConvertDMToDD(Number(data.config.longitude_deg),Number(data.config.longitude_minutes),data.config.longitude_heading);
  config.owmkey = data.config.owmkey;
  console.log("key: ",config.owmkey);
  config.consoleunits = data.config.consoleunits;
  config.forecastGap = Number(data.config.gap);
  
  // initialise gauge canvas 
  initCanvas('wind');
  initCanvas('sun-chart');
  initCanvas('barometer-gauge');  
}	
	
function initialData(text){
  data = JSON.parse(text);
/*
  // station lat/lon values for solar stats calculator
  config.latitude = ConvertDMToDD(Number(data.config.latitude_deg),Number(data.config.latitude_minutes),data.config.latitude_heading);
  config.longitude = ConvertDMToDD(Number(data.config.longitude_deg),Number(data.config.longitude_minutes),data.config.longitude_heading);
  config.owmkey = data.config.owmkey;
  config.consoleunits = data.config.consoleunits;
  config.forecastGap = Number(data.config.gap);
 
  // initialise gauge canvas 
  initCanvas('wind');
  initCanvas('sun-chart');
  initCanvas('barometer-gauge');   
  */
  // Update all current readings by iterating through all current value keys
  Object.keys(data.current).forEach(item => updateHTML(item,data.current[item]));
  updateHTML('beaufort_description',(Number(beaufort(data.current.wind_avg))+1)+ ' : '+beaufortWindForceScale[Number(beaufort(data.current.wind_avg))]['Description']);
  
  // get and display the forecast from OpenWeatherMap
  getForecast(config.latitude,config.longitude,config.owmkey,config.consoleunits,config.forecastGap);

  // calc and display sunrise and sunset details
  populateSunRiseSet(config.latitude,config.longitude);
  var today = new Date();
   
  drawWind(needle);
  drawRoundGaugeTwoNeedles('barometer-gauge', Math.round(data.current.barometer),Math.round(data.current.barometer_day_ago), 160, 380, 950, 1050,'hPa');
  drawSun('sun-chart',SunCalc.getTimes(today, config.latitude,config.longitude));
}

function updateData(text){
	console.log("Updating Data",text);
  data = JSON.parse(text);
  
  // Update all current readings by iterating through all current value keys
  Object.keys(data.current).forEach(item => updateHTML(item,data.current[item]));
  updateHTML('beaufort_description',(Number(beaufort(data.current.wind_avg))+1)+ ' : '+beaufortWindForceScale[Number(beaufort(data.current.wind_avg))]['Description']);
  
  // get and display the forecast from OpenWeatherMap
  getForecast(config.latitude,config.longitude,config.owmkey,config.consoleunits,config.forecastGap);

  // calc and display sunrise and sunset details
  populateSunRiseSet(config.latitude,config.longitude);
  var today = new Date();
  
  
  drawWind(needle);
  drawRoundGaugeTwoNeedles('barometer-gauge', Math.round(data.current.barometer),Math.round(data.current.barometer_day_ago), 160, 380, 950, 1050,'hPa');
  drawSun('sun-chart',SunCalc.getTimes(today, config.latitude,config.longitude));
}

// read values from json
function loadJSON(file,callback) {

    var xobj = new XMLHttpRequest();
        xobj.overrideMimeType("application/json");
    xobj.open('GET', file);
    xobj.onreadystatechange = function () {
          if (xobj.readyState == 4 && xobj.status == "200") {
            // Required use of an anonymous callback as .open will NOT return a value but simply returns undefined in asynchronous mode
            callback(xobj.responseText);
          }
    };
    xobj.send(null);
 }



//Get forecast from Open Weather Map

async function getForecast(latitudeDeg,longitudeDeg,owmkey,units,gap) {

  var owmurl="http://api.openweathermap.org/data/2.5/onecall?lat="+latitudeDeg+"&lon="+longitudeDeg+"&exclude=current,minutely,daily&units="+units+"&appid="+owmkey;
console.log(owmurl);
  const response = await fetch(owmurl);

  const forecastJson = await response.json(); //extract JSON from the http response
  forecast = forecastJson['hourly'];  // extract the hourly forecast

  // loop through each of the 3 sets of forecasts allowed in the pane
  for(x=1;x<4;x++){
  // an index to get the correct forecast from the API response
    forecastNumber = 1+(x-1)*gap;

    // get the sunrise/sunset needed to calculate if the forecast time is during day time
    var d = new Date(forecast[forecastNumber]['dt']*1000);
    sunTimes = SunCalc.getTimes(d, latitudeDeg, longitudeDeg);

    // determine if time of forecast is day or night for icon
    if((forecast[forecastNumber]['dt']*1000 > sunTimes.sunrise.getTime()) && (forecast[forecastNumber]['dt']*1000 < sunTimes.sunset.getTime()) )
      owmtime='day';
    else
      owmtime='night';

    // get the hour of the forecast and convert from 24hr to 12hr clock for the weather font clock icon
    forecasthour = d.getHours();
    if (Number(forecasthour) > 12) {
      forecastTime = Number(forecasthour) - 12;
    }
    else if (Number(forecasthour) == 0) {
      forecastTime = 12;
    }
    else {
      forecastTime = Number(forecasthour)
    }



    // Icons from https://erikflowers.github.io/weather-icons/
    updateHTML('forecast-hour-'+x+'-time',"<i class=\"wi wi-time-" + forecastTime + "\"></i>" );
    updateHTML('forecast-hour-'+x+'-icon',"<i class=\"wi wi-owm-"+owmtime+"-"+ forecast[forecastNumber]['weather'][0]['id'] + "\"></i><span class=\"tooltiptext\">"+forecast[forecastNumber]['weather'][0]['description']+"</span>");
    updateHTML('forecast-hour-'+x+'-temp',Math.round(forecast[forecastNumber]['temp']));
    updateHTML('forecast-hour-'+x+'-precip-percent',Math.round(100*forecast[forecastNumber]['pop']));
    updateHTML('forecast-hour-'+x+'-wind-dir',"<i class=\"wi wi-wind from-" + forecast[forecastNumber]['wind_deg'] + "-deg\"></i>");
    updateHTML('forecast-hour-'+x+'-wind-spd',Math.round(forecast[forecastNumber]['wind_speed']*10)/10);
  }
}
// end get forecast


// convert lat and long to decimal from format that WeeWx outputs
function ConvertDMToDD(degrees, minutes, direction) {
    var dd = degrees + minutes/60 ;

    if (direction == "S" || direction == "W") {
        dd = dd * -1;
    } // Don't do anything for N or E
    return dd;
}


function populateSunRiseSet(latitude, longitude) {
  today = new Date();
  tomorrow = new Date()
  tomorrow.setDate(tomorrow.getDate() + 1)

  let sunTimes = SunCalc.getTimes(today, latitude, longitude);
  let tomorrowSunTimes = SunCalc.getTimes(tomorrow, latitude, longitude);

  lengthToday = sunTimes.sunset.getTime() - sunTimes.sunrise.getTime(); //in milliseconds
  lengthTomorrow = tomorrowSunTimes.sunset.getTime() - tomorrowSunTimes.sunrise.getTime(); //in milliseconds
  diffDayLength = lengthTomorrow-lengthToday; // in milliseconds


  let sunriseStr = getHumanTimeHHMM(sunTimes.sunrise.getTime() / 1000);
  let sunsetStr = getHumanTimeHHMM(sunTimes.sunset.getTime() / 1000);
  let solarNoonStr = getHumanTimeHHMM(sunTimes.solarNoon.getTime() / 1000);
  let tomorrowSunriseStr = getHumanTimeHHMM(tomorrowSunTimes.sunrise.getTime() / 1000);
  let tomorrowSunsetStr = getHumanTimeHHMM(tomorrowSunTimes.sunset.getTime() / 1000);
  let tomorrowSolarNoonStr = getHumanTimeHHMM(tomorrowSunTimes.solarNoon.getTime() / 1000);
  updateHTML('sunrise_time', sunriseStr);
  updateHTML('sunset_time', sunsetStr);
  updateHTML('solarnoon_time', solarNoonStr);
  updateHTML('tomorrow_sunrise_time', tomorrowSunriseStr);
  updateHTML('tomorrow_sunset_time', tomorrowSunsetStr);
  updateHTML('tomorrow_solarnoon_time', tomorrowSolarNoonStr);
  if(diffDayLength>0){
    updateHTML('solar_tomorrow_text', getHumanTimeMMSS(diffDayLength/1000)+" longer");
  }
  else {
    updateHTML('solar_tomorrow_text', getHumanTimeMMSS(-diffDayLength/1000)+" shorter");
  }
}

// update element HTML
function updateHTML(updateElement, value) {
  if (document.getElementsByClassName(updateElement)) {
    var getClass = document.getElementsByClassName(updateElement);
    for (i = 0; i < getClass.length; i++) {
      getClass[i].innerHTML = value;
    }
  }
} // end updateHTML

function getHumanTimeHHMM(epoch) {
  var d = new Date(epoch * 1000);
  time = pad(d.getHours(), 2) + ":" + pad(d.getMinutes(), 2);

  return time;
} // end getHumanTimeHHMM

function getHumanTimeMMSS(epoch) {
  var d = new Date(epoch * 1000);
  time = pad(d.getMinutes(), 2) + ":" + pad(d.getSeconds(), 2);

  return time;
}

// pad leading zeros in numbers
function pad(n, len) {

  s = n.toString();
  if (s.length < len) {
    s = ('0000000000' + s).slice(-len);
  }

  return s;
}



// round gauge with a single line of text (value+units)
function drawRoundGaugeTwoNeedles(canvasID, value, valueTwo, minAngle = 270, maxAngle = 630, minValue = 0, maxValue = 360, units = '') {
  let canvas = document.getElementById(canvasID);
  //get context
  let gauge = canvas.getContext('2d');
  // get properties of canvas
  width = Number(getComputedStyle(canvas).getPropertyValue("width").slice(0, -2));
  height = Number(getComputedStyle(canvas).getPropertyValue("height").slice(0, -2));
  // to find radius for gauge
  if (width >= height) {
    size = height;
  } else {
    size = width;
  }

  // clear canvas
  gauge.clearRect(0, 0, width, height); // clear canvas

  // adjust dimensions based on canvas dimensions
  gauge.lineWidth = size * 0.04;
  gaugeRadius = (-gauge.lineWidth - size * 0.1) + size / 2;
  gaugeFontSize = size / 10;
  gauge.font = gaugeFontSize + "px Arial";
  needleBase = size * 0.04;
  needleHeight = needleBase * 3.2;
  needleTwoBase = needleBase*0.7;
  needleTwoHeight = needleHeight * 0.7;

  // get sagitta (height) of arc
  sagitta = gaugeRadius*(1-Math.cos(0.5*((maxAngle-minAngle)*Math.PI/180)));
  // amount to move gauge down to centre based on sagitta, not radius
  centre = (2 * gaugeRadius - sagitta)/2;



  // set colours from CSS for text
  gauge.fillStyle = cssvar('--page-text-colour');
  gauge.strokeStyle = cssvar('--page-text-colour');



  // print wind direction, speed and Beaufort description in centre of dial
  gauge.textAlign = "center";

  gauge.fillText(value + " " + units, width / 2, centre+height / 2);

  gauge.fillStyle = cssvar('--needle-colour');
  gauge.strokeStyle = cssvar('--gauge-colour');

  // draw dial


  gauge.translate(width / 2, centre+height / 2); // translate resets (0,0) coords to centre of canvas
  gauge.beginPath();
  gauge.arc(0, 0, gaugeRadius, minAngle * Math.PI / 180, maxAngle * Math.PI / 180);
  // x=0,y=0,radius,start angle 0= 3 o'clock, end angle, <direction>
  gauge.stroke();

  // draw needle
  gauge.beginPath();
  needleAngle = (maxAngle - minAngle) * (value - minValue) / (maxValue - minValue);

  gauge.rotate(-(270 - minAngle) * Math.PI / 180); // how does this work. Rotates to start angle?
  gauge.rotate(needleAngle * Math.PI / 180); //rotate to draw at current deg value
  gauge.translate(0, -gaugeRadius - gauge.lineWidth / 2); // move to radius new 0,0
  gauge.lineTo(needleBase, 0); // draw half of base line
  gauge.lineTo(0, needleHeight); // draw to point
  gauge.lineTo(-needleBase, 0); // draw back to other end of base line
  gauge.fill(); // close fill triangle
  gauge.translate(0, gaugeRadius + gauge.lineWidth / 2); // move back to centre of canvas

gauge.rotate(-needleAngle * Math.PI / 180); //rotate back to start angle
gauge.rotate((270 - minAngle) * Math.PI / 180); // rotate back from start angle to beginning

  gauge.fillStyle = cssvar('--needle-old-colour');

  // needleTwo
  gauge.beginPath();
  needleAngle = (maxAngle - minAngle) * (valueTwo - minValue) / (maxValue - minValue);
  gauge.rotate(-(270 - minAngle) * Math.PI / 180);

  gauge.rotate(needleAngle * Math.PI / 180); //rotate to draw at current deg value
  gauge.translate(0, -gaugeRadius - gauge.lineWidth / 2); // move to radius
  gauge.lineTo(needleTwoBase, 0); // draw half of base line
  gauge.lineTo(0, needleTwoHeight); // draw to point
  gauge.lineTo(-needleTwoBase, 0); // draw back to other end of base line
  gauge.fill(); // close fill triangle

  gauge.translate(0, gaugeRadius + gauge.lineWidth / 2); // move back to centre of canvas

  gauge.rotate(-needleAngle * Math.PI / 180); //rotate back
  gauge.rotate((270 - minAngle) * Math.PI / 180);
  gauge.translate(-width / 2, -(centre+height / 2)); // move back to (0,0) ready for next animation

}

// round gauge with a single line of text (value+units)
function drawRoundGauge(canvasID, value, minAngle = 270, maxAngle = 630, minValue = 0, maxValue = 360, units = '') {
  let canvas = document.getElementById(canvasID);
  //get context
  let gauge = canvas.getContext('2d');
  // get properties of canvas
  width = Number(getComputedStyle(canvas).getPropertyValue("width").slice(0, -2));
  height = Number(getComputedStyle(canvas).getPropertyValue("height").slice(0, -2));

  // to find radius for gauge
  if (width >= height) {
    size = height;
  } else {
    size = width;
  }
  // clear canvas
  gauge.clearRect(0, 0, width, height); // clear canvas

  // adjust dimensions based on canvas dimensions
  gauge.lineWidth = size * 0.04;
  gaugeRadius = (-gauge.lineWidth - size * 0.1) + size / 2;
  gaugeFontSize = size / 10;
  gauge.font = gaugeFontSize + "px Arial";
  needleBase = size * 0.04;
  needleHeight = needleBase * 3.2;

  // set colours from CSS
  gauge.fillStyle = "#bbbbbb";
  gauge.strokeStyle = "#bbbbbb";

  // print wind direction, speed and Beaufort description in centre of dial
  gauge.textAlign = "center";

  gauge.fillText(value + " " + units, width / 2, height / 2);

  gauge.fillStyle = cssvar('--needle-colour');
  gauge.strokeStyle = cssvar('--gauge-colour');

  // draw dial
  gauge.beginPath();

  gauge.translate(width / 2, height / 2);

  gauge.arc(0, 0, gaugeRadius, minAngle * Math.PI / 180, maxAngle * Math.PI / 180);
  // x=0,y=0,radius,start angle 0= 3 o'clock, end angle, <direction>
  gauge.stroke();

  // draw needle
  gauge.beginPath();



  needleAngle = (maxAngle - minAngle) * (value - minValue) / (maxValue - minValue);


  gauge.rotate(-(270 - minAngle) * Math.PI / 180);

  gauge.rotate(needleAngle * Math.PI / 180); //rotate to draw at current deg value
  gauge.translate(0, -gaugeRadius - gauge.lineWidth / 2); // move to radius
  gauge.lineTo(needleBase, 0); // draw half of base line
  gauge.lineTo(0, needleHeight); // draw to point
  gauge.lineTo(-needleBase, 0); // draw back to other end of base line
  gauge.fill(); // close fill triangle

  gauge.translate(0, gaugeRadius + gauge.lineWidth / 2); // move back to centre of canvas

  gauge.rotate(-needleAngle * Math.PI / 180); //rotate back
  gauge.rotate((270 - minAngle) * Math.PI / 180);
  gauge.translate(-width / 2, -height / 2); // move back to (0,0) ready for next animation

}

// initialise canvas to size of parent
async function initCanvas(canvasID) {

  //get canvas
  let canvas = document.getElementById(canvasID);

  //get context
  let ctx = canvas.getContext('2d');

  function parentWidth(elem) {
    return elem.parentElement.clientWidth;
  }

  function parentHeight(elem) {
    return elem.parentElement.clientHeight;
  }

  // gets width and height of parent and sets canvas to match
  parentWidth = parentWidth(document.getElementById(canvasID));
  parentHeight = parentHeight(document.getElementById(canvasID));
  canvasWidth = parentWidth;
  canvasHeight = parentHeight;

  // scale canvas to match screen for sharpness
  scale = window.devicePixelRatio;
  canvas.style.width = canvasWidth + "px";
  canvas.style.height = canvasHeight + "px";
  canvas.width = canvasWidth * scale;
  canvas.height = canvasHeight * scale;
  ctx.scale(scale, scale);
  // now that canvas is initialised it can be drawn on
}

// utility function to fetch the variables from the CSS
function cssvar(name) {
  return getComputedStyle(document.documentElement).getPropertyValue(name);
}

// function to load scripts in correct order
//const loadScript = src => {
function loadScript(src) {
  return new Promise((resolve, reject) => {
    const script = document.createElement('script')
    script.type = 'text/javascript'
    script.onload = resolve
    script.onerror = reject
    script.src = src
    document.head.append(script)
  })
}

function startConnect() {
    // Generate a random client ID
    clientID = "clientID-" + parseInt(Math.random() * 100);

    // Fetch the hostname/IP address and port number from the form
    host = "broker.hivemq.com";
    port = "8000";

    // Print output for the user in the messages div
    console.log( 'Connecting to: ', host ,' on port: ', port );

    // Initialize new Paho client connection
    client = new Paho.MQTT.Client(host, Number(port), clientID);

    // Set callback handlers
    client.onConnectionLost = onConnectionLost;
    client.onMessageArrived = onMessageArrived;

    // Connect the client, if successful, call onConnect function
    client.connect({
        'onSuccess': onConnect,
        'useSSL': false
    });
}

// Called when the client connects
function onConnect() {
    // Fetch the MQTT topic from the form
    topic = "sunnysideweather/loop";

    // Print output for the user in the messages div
    console.log('Subscribing to: ',topic);

    // Subscribe to the requested topic
    client.subscribe(topic);
}

// Called when the client loses its connection
function onConnectionLost(responseObject) {
    console.log("onConnectionLost: Connection Lost");
    if (responseObject.errorCode !== 0) {
        console.log("onConnectionLost: " + responseObject.errorMessage);
    }
}

// Called when a message arrives
function onMessageArrived(message) {
	var mqttData = JSON.parse(message.payloadString);
    
	// This message is a weewx archive update.
    if ( mqttData.hasOwnProperty("interval_minute") ) {
		console.log("Starting refresh in 15 seconds");
		setTimeout( loadJSON, 15000,"js/data.json", updateData ); // Update weewx data
	}
	else{ // update from mqttData

updateHTML('air_temperature',(Math.round(10*mqttData.outTemp_C)/10).toFixed(1));
updateHTML('obs_time',getHumanTimeHHMM(mqttData.dateTime));
updateHTML('wind_gust',(Math.round(10*mqttData.windGust_mps)/10).toFixed(1));
updateHTML('wind_speed',(Math.round(10*mqttData.windSpeed_mps)/10).toFixed(1));
updateHTML('solar_radiation',Math.round(mqttData.radiation_Wpm2));
updateHTML('uv',Math.round(mqttData.UV));



console.log("mqtt spd: ",mqttData.windSpeed_mps," degrees: ",mqttData.windDir);



if(needle.moving == 0){ // check that the needle is not currently mid animation
  needle.windSpeed = mqttData.windSpeed_mps;
  if(Number(mqttData.windSpeed_mps) != 0){
	needle.targetDegrees=mqttData.windDir;
	needle.targetCardinal = cardinal(needle.targetDegrees);
	console.log("Wind update");
  }
  rotateWindNeedle();
}
else{
	console.log("Wind already animating");
}
	}
}

// Called when the disconnection button is pressed
function startDisconnect() {
    client.disconnect();
}

//******************************************************
// draw sun path chart
//******************************************************

function drawSun(canvasID, sunTimes) {

// extract times for the calculation
  sunrise = sunTimes.sunrise.getTime();
  sunset = sunTimes.sunset.getTime();
  transit = sunTimes.solarNoon.getTime();
  var currentTime = new Date();

  let canvas = document.getElementById(canvasID);
  //get context
  let gauge = canvas.getContext('2d');
  // get properties of canvas
  width = Number(getComputedStyle(canvas).getPropertyValue("width").slice(0, -2));
  height = Number(getComputedStyle(canvas).getPropertyValue("height").slice(0, -2));

  // clear canvas
  gauge.clearRect(0, 0, width, height); // clear canvas

  // adjust dimensions based on canvas dimensions
  gauge.lineWidth = width * 0.001;

  // set colours
  gauge.fillStyle = "#FFA500";
  gauge.strokeStyle = "#FFA500";

  // draw dial
  gauge.setLineDash([1, 3]);
  gauge.beginPath();

  gauge.beginPath();

   gauge.moveTo(10, height-10);  // start point left side of canvas
   gauge.quadraticCurveTo(
       width/4, 10,     // controls point sets slope out from start and into center
       width/2,10              // center point
   );
   gauge.quadraticCurveTo(
       3*width/4, 10,     // control point sets slope out from center and into last point
       width-10, height -10          // last point
   );

  gauge.stroke();



  // start to draw sun
  // remove dashes
  gauge.setLineDash([]);
  gauge.lineWidth = width * 0.003;
  gauge.strokeStyle = "#FFD700";
  gauge.fillStyle = "#FFD700";
  timeOfDay="dark";
  console.log(currentTime.getTime() - sunrise);
  console.log(currentTime.getTime() - transit);
  console.log(sunrise," ",currentTime.getTime(), " ",transit," ",sunset);
if(currentTime.getTime() > sunrise && currentTime.getTime() <= transit){

  timeOfDay = "am";
  percentage = (currentTime - sunrise)/(transit-sunrise);
  console.log("am ",percentage);
  coords = getQuadraticXY(percentage, 10, height-10,width/4, 10, width/2,10);
}
else if (currentTime>transit && currentTime < sunset){

  timeOfDay = "pm";
  percentage = (currentTime - transit)/(sunset-transit);


  coords = getQuadraticXY(percentage,width/2,10,3*width/4, 10, width-10, height -10 );
}
if(timeOfDay != "dark"){


pointX = coords.x;
pointY = coords.y;

gauge.beginPath();
// draw circle body of sun
gauge.arc(pointX, pointY, 3, 0, Math.PI * 2);
gauge.fill();

// reset (0,0) to centre of 'sun'
gauge.translate(pointX,pointY);
for(var y=0;y<8;y++){
  gauge.moveTo(0,6);
  gauge.lineTo(0,9);
  gauge.stroke();
  gauge.rotate(Math.PI/4);
}
gauge.translate(-pointX,-pointY);

}}

function getQuadraticXY(t, sx, sy, cp1x, cp1y, ex, ey) {
  return {
    x: (1-t) * (1-t) * sx + 2 * (1-t) * t * cp1x + t * t * ex,
    y: (1-t) * (1-t) * sy + 2 * (1-t) * t * cp1y + t * t * ey
  };
}


// Beaufort Wind Force Scale based on data at https://www.rmets.org/resource/beaufort-scale
function beaufort(mps) {
  kph = mps * 3.6;
  if (kph < 1)
    return 0;
  else if (kph < 6)
    return 1;
  else if (kph < 12)
    return 2;
  else if (kph < 20)
    return 3;
  else if (kph < 29)
    return 4;
  else if (kph < 38)
    return 5;
  else if (kph < 50)
    return 6;
  else if (kph < 62)
    return 7;
  else if (kph < 75)
    return 8;
  else if (kph < 89)
    return 9;
  else if (kph < 103)
    return 10;
  else if (kph < 118)
    return 11;
  else
    return 12;
}


beaufortWindForceScale = [{
    Description: 'Calm',
    Specification: 'Smoke rises vertically'
  },
  {
    Description: 'Light Air',
    Specification: 'Direction shown by smoke drift but not by wind vanes'
  },
  {
    Description: 'Light Breeze',
    Specification: 'Wind felt on face; leaves rustle; wind vane moved by wind'
  },
  {
    Description: 'Gentle Breeze',
    Specification: 'Leaves and small twigs in constant motion; light flags extended'
  },
  {
    Description: 'Moderate Breeze',
    Specification: 'Raises dust and loose paper; small branches moved.'
  },
  {
    Description: 'Fresh Breeze',
    Specification: 'Small trees in leaf begin to sway; crested wavelets form on inland waters.'
  },
  {
    Description: 'Strong Breeze',
    Specification: 'Large branches in motion; whistling heard in telegraph wires; umbrellas used with difficulty.'
  },
  {
    Description: 'Near Gale',
    Specification: 'Whole trees in motion; inconvenience felt when walking against the wind.'
  },
  {
    Description: 'Gale',
    Specification: 'Twigs break off trees; generally impedes progress.'
  },
  {
    Description: 'Strong Gale',
    Specification: 'Slight structural damage (chimney pots and slates removed).'
  },
  {
    Description: 'Storm',
    Specification: 'Seldom experienced inland; trees uprooted; considerable structural damage'
  },
  {
    Description: 'Violent Storm',
    Specification: 'Very rarely experienced; accompanied by widespread damage.'
  },
  {
    Description: 'Hurricane',
    Specification: 'Devastation'
  }
];


// draws the wind compass based on the values in needle
function drawWind(needle) {
  let canvas = document.getElementById('wind');
  //get context
  let wind = canvas.getContext('2d');
  // get properties of canvas
  width = Number(getComputedStyle(canvas).getPropertyValue("width").slice(0, -2));
  height = Number(getComputedStyle(canvas).getPropertyValue("height").slice(0, -2));

  // to find radius for gauge
  if (width >= height) {
    size = height;
  } else {
    size = width;
  }

  // clear canvas
  wind.clearRect(0, 0, width, height); // clear canvas

  // adjust dimensions based on canvas dimensions
  wind.lineWidth = size * 0.04;
  arcWidth = wind.lineWidth;
  gaugeRadius = (-wind.lineWidth - size * 0.1) + size / 2;
  windFontSize = size / 10;
  wind.font = windFontSize + "px Arial";
  needle.base = size * 0.04;
  needle.height = needle.base * 3.2;


  // draw dial
  wind.beginPath();
  wind.strokeStyle = cssvar('--wind-gauge-colour');
  wind.translate(width / 2, height / 2);
  wind.arc(0, 0, gaugeRadius, 0, Math.PI * 2); //draw gauge arc
  wind.stroke();

  // draw needle
  wind.lineWidth = size * 0.007;
  wind.beginPath();
  wind.rotate(needle.degrees * Math.PI / 180); //rotate to draw at current deg value
  wind.translate(0, -gaugeRadius - arcWidth/2); // move to radius
  wind.moveTo(0,0);
  
  wind.strokeStyle = cssvar('--bws-'+ beaufort(needle.windSpeed)); // set colour of needle to reflect beaufort, css var
  wind.fillStyle = wind.strokeStyle;
  
  wind.lineTo(needle.base, -arcWidth); // draw half of base line
  wind.lineTo(0, needle.height); // draw to point
  wind.lineTo(-needle.base, -arcWidth); // draw back to other end of base line
  wind.closePath(); // close needle shape
  wind.stroke();
  wind.fill();	 
  // fill needle	 
  /*wind.beginPath();
	  wind.moveTo(0,0);
      wind.lineTo(needle.base, -arcWidth); // draw half of base line
      wind.lineTo(0, needle.height); // draw to point
      wind.lineTo(-needle.base, -arcWidth); // draw back to other end of base line
	  wind.fill();
  */
  
  wind.translate(0, gaugeRadius + arcWidth/2); // move back to centre of canvas
  wind.rotate(-needle.degrees * Math.PI / 180); //rotate back to beginning
  wind.translate(-width / 2, -height / 2); // move back to (0,0) ready for next animation
  
  // print wind direction, speed and Beaufort description in centre of dial
  wind.textAlign = "center";
  wind.fillText(needle.targetCardinal, width / 2, -0.2 * windFontSize + height / 2);
  wind.fillText(Math.round(needle.windSpeed * 10) / 10 , width / 2, 0.8 * windFontSize + height / 2);
  
}

/**********************************************
* updates values in needle then draws and will animate until target angle is met
**********************************************/
function rotateWindNeedle() {
  // calculate direction to animate wind needle
  change = needle.targetDegrees - needle.degrees; // difference between current angle and target

  if (change != 0) { // if there is a difference between current direction and new direction
    if (((change + 360) % 360 > 180) && needle.moving == 0) { //(clockwise, anti-clockwise whichever is closest)
      needle.direction = -1; // anti-clockwise
    }
    needle.moving = 1; // to show that we've started animation
    needle.degrees = needle.degrees + needle.direction; // add/remove degree per animation loop

    // deal with 0/360 degree
    if (needle.degrees > 359)
      needle.degrees = 0;
    if (needle.degrees < 0)
      needle.degrees = 359;

    // draw the canvas then request next frame in animation
    drawWind(needle);
    requestAnimationFrame(rotateWindNeedle);
  } else { // current and target are now the same, animation complete
	// may be same direction but different speed, so draw needle to update text
	drawWind(needle);
    needle.moving = 0;
    needle.direction = 1;
  }
}


/**********************************************
* determines wind cardinal direction from degrees
**********************************************/
function cardinal(deg){
	 if (deg>11.25 && deg<=33.75){
    return "NNE";
  }else if (deg>33.75 && deg<=56.25){
    return "NE";
  }else if (deg>56.25 && deg<=78.75){
    return "ENE";
  }else if (deg>78.75 && deg<=101.25){
    return "E";
  }else if (deg>101.25 && deg<=123.75){
    return "ESE";
  }else if (deg>123.75 && deg<=146.25){
    return "SE";
  }else if (deg>146.25 && deg<=168.75){
    return "SSE";
  }else if (deg>168.75 && deg<=191.25){
    return "S";
  }else if (deg>191.25 && deg<=213.75){
    return "SSW";
  }else if (deg>213.75 && deg<=236.25){
    return "SW";
  }else if (deg>236.25 && deg<=258.75){
    return "WSW";
  }else if (deg>258.75 && deg<=281.25){
    return "W";
  }else if (deg>281.25 && deg<=303.75){
    return "WNW";
  }else if (deg>303.75 && deg<=326.25){
    return "NW";
  }else if (deg>326.25 && deg<=348.75){
    return "NNW";
  }else{
    return "N"; 
  }
}// end cardinal

// utility get url
function get_relative_url() {
    var sPath = window.location.pathname.replace(/\/$/, "");
    pageName = sPath.substring(sPath.lastIndexOf('/') + 1);
    if ( pages.includes( pageName ) ) {
        var relative_url = "..";
    } else {
        var relative_url = ".";
    }
    belchertown_debug("URL: Relative URL is: " + relative_url);

    return relative_url;
}

