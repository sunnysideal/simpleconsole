// read values from json
function loadJSON(file,callback) {   

    var xobj = new XMLHttpRequest();
        xobj.overrideMimeType("application/json");
    xobj.open('GET', file); 
    xobj.onreadystatechange = function () {
          if (xobj.readyState == 4 && xobj.status == "200") {
            // Required use of an anonymous callback as .open will NOT return a value but simply returns undefined in asynchronous mode
            callback(xobj.responseText);
          }
    };
    xobj.send(null);  
 }

// callback, entry point here after data is read
loadJSON("js/data.json", function(text){
  data = JSON.parse(text);
  
  // Update all current readings by iterating through all current value keys
  Object.keys(data.current).forEach(item => updateHTML(item,data.current[item]));

  // station lat/lon values for solar stats calculator
  var latitudeDeg = ConvertDMToDD(Number(data.config.latitude_deg),Number(data.config.latitude_minutes),Number(data.config.latitude_heading));
  var longitudeDeg = ConvertDMToDD(Number(data.config.longitude_deg),Number(data.config.longitude_minutes),Number(data.config.longitude_heading));
  
  // get and display the forecast from OpenWeatherMap
  getForecast(latitudeDeg,longitudeDeg,data.config.owmkey,data.config.consoleunits,Number(data.config.gap));
  
  // calc and display sunrise and sunset details
  populateSunRiseSet(latitudeDeg,longitudeDeg);

  // baro gauge
  initCanvas('barometer-gauge');
  drawRoundGaugeTwoNeedles('barometer-gauge', Math.round(data.current.barometer),Math.round(data.current.barometer_day_ago), 160, 380, 950, 1050,'hPa');

});


//Get forecast from Open Weather Map

async function getForecast(latitudeDeg,longitudeDeg,owmkey,units,gap) {
  
  var owmurl="http://api.openweathermap.org/data/2.5/onecall?lat="+latitudeDeg+"&lon="+longitudeDeg+"&exclude=current,minutely,daily&units="+units+"&appid="+owmkey;
  
  const response = await fetch(owmurl);
  
  const forecastJson = await response.json(); //extract JSON from the http response
  forecast = forecastJson['hourly'];  // extract the hourly forecast

  // loop through each of the 3 sets of forecasts allowed in the pane
  for(x=1;x<4;x++){
  // an index to get the correct forecast from the API response
    forecastNumber = 1+(x-1)*gap;

    // get the sunrise/sunset needed to calculate if the forecast time is during day time
    var d = new Date(forecast[forecastNumber]['dt']*1000);
    sunTimes = SunCalc.getTimes(d, latitudeDeg, longitudeDeg);

    // determine if time of forecast is day or night for icon
    if((forecast[forecastNumber]['dt']*1000 > sunTimes.sunrise.getTime()) && (forecast[forecastNumber]['dt']*1000 < sunTimes.sunset.getTime()) )
      owmtime='day';
    else
      owmtime='night';

    // get the hour of the forecast and convert from 24hr to 12hr clock for the weather font clock icon
    forecasthour = d.getHours();
    if (Number(forecasthour) > 12) {
      forecastTime = Number(forecasthour) - 12;
    }
    else if (Number(forecasthour) == 0) {
      forecastTime = 12;
    }
    else {
      forecastTime = Number(forecasthour)
    }



    // Icons from https://erikflowers.github.io/weather-icons/
    updateHTML('forecast-hour-'+x+'-time',"<i class=\"wi wi-time-" + forecastTime + "\"></i>" );
    updateHTML('forecast-hour-'+x+'-icon',"<i class=\"wi wi-owm-"+owmtime+"-"+ forecast[forecastNumber]['weather'][0]['id'] + "\"></i><span class=\"tooltiptext\">"+forecast[forecastNumber]['weather'][0]['description']+"</span>");
    updateHTML('forecast-hour-'+x+'-temp',Math.round(forecast[forecastNumber]['temp']));
    updateHTML('forecast-hour-'+x+'-precip-percent',forecast[forecastNumber]['pop']);
    updateHTML('forecast-hour-'+x+'-wind-dir',"<i class=\"wi wi-wind from-" + forecast[forecastNumber]['wind_deg'] + "-deg\"></i>");
    updateHTML('forecast-hour-'+x+'-wind-spd',Math.round(forecast[forecastNumber]['wind_speed']*10)/10);
  }
}
// end get forecast


// convert lat and long to decimal from format that WeeWx outputs
function ConvertDMToDD(degrees, minutes, direction) {
    var dd = degrees + minutes/60 ;

    if (direction == "S" || direction == "W") {
        dd = dd * -1;
    } // Don't do anything for N or E
    return dd;
}


function populateSunRiseSet(latitude, longitude) {
  today = new Date();
  tomorrow = new Date()
  tomorrow.setDate(tomorrow.getDate() + 1)

  let sunTimes = SunCalc.getTimes(today, latitude, longitude);
  let tomorrowSunTimes = SunCalc.getTimes(tomorrow, latitude, longitude);

  lengthToday = sunTimes.sunset.getTime() - sunTimes.sunrise.getTime(); //in milliseconds
  lengthTomorrow = tomorrowSunTimes.sunset.getTime() - tomorrowSunTimes.sunrise.getTime(); //in milliseconds
  diffDayLength = lengthTomorrow-lengthToday; // in milliseconds


  let sunriseStr = getHumanTimeHHMM(sunTimes.sunrise.getTime() / 1000);
  let sunsetStr = getHumanTimeHHMM(sunTimes.sunset.getTime() / 1000);
  let solarNoonStr = getHumanTimeHHMM(sunTimes.solarNoon.getTime() / 1000);
  let tomorrowSunriseStr = getHumanTimeHHMM(tomorrowSunTimes.sunrise.getTime() / 1000);
  let tomorrowSunsetStr = getHumanTimeHHMM(tomorrowSunTimes.sunset.getTime() / 1000);
  let tomorrowSolarNoonStr = getHumanTimeHHMM(tomorrowSunTimes.solarNoon.getTime() / 1000);
  updateHTML('sunrise_time', sunriseStr);
  updateHTML('sunset_time', sunsetStr);
  updateHTML('solarnoon_time', solarNoonStr);
  updateHTML('tomorrow_sunrise_time', tomorrowSunriseStr);
  updateHTML('tomorrow_sunset_time', tomorrowSunsetStr);
  updateHTML('tomorrow_solarnoon_time', tomorrowSolarNoonStr);
  if(diffDayLength>0){
    updateHTML('solar_tomorrow_text', getHumanTimeMMSS(diffDayLength/1000)+" longer");
  }
  else {
    updateHTML('solar_tomorrow_text', getHumanTimeMMSS(-diffDayLength/1000)+" shorter");
  }
}

// update element HTML
function updateHTML(updateElement, value) {
  if (document.getElementsByClassName(updateElement)) {
    var getClass = document.getElementsByClassName(updateElement);
    for (i = 0; i < getClass.length; i++) {
      getClass[i].innerHTML = value;
    }
  }
} // end updateHTML

function getHumanTimeHHMM(epoch) {
  var d = new Date(epoch * 1000);
  time = pad(d.getHours(), 2) + ":" + pad(d.getMinutes(), 2);

  return time;
} // end getHumanTimeHHMM

function getHumanTimeMMSS(epoch) {
  var d = new Date(epoch * 1000);
  time = pad(d.getMinutes(), 2) + ":" + pad(d.getSeconds(), 2);

  return time;
}

// pad leading zeros in numbers
function pad(n, len) {

  s = n.toString();
  if (s.length < len) {
    s = ('0000000000' + s).slice(-len);
  }

  return s;
}



// round gauge with a single line of text (value+units)
function drawRoundGaugeTwoNeedles(canvasID, value, valueTwo, minAngle = 270, maxAngle = 630, minValue = 0, maxValue = 360, units = '') {
  let canvas = document.getElementById(canvasID);
  //get context
  let gauge = canvas.getContext('2d');
  // get properties of canvas
  width = Number(getComputedStyle(canvas).getPropertyValue("width").slice(0, -2));
  height = Number(getComputedStyle(canvas).getPropertyValue("height").slice(0, -2));
  // to find radius for gauge
  if (width >= height) {
    size = height;
  } else {
    size = width;
  }

  // clear canvas
  gauge.clearRect(0, 0, width, height); // clear canvas

  // adjust dimensions based on canvas dimensions
  gauge.lineWidth = size * 0.04;
  gaugeRadius = (-gauge.lineWidth - size * 0.1) + size / 2;
  gaugeFontSize = size / 10;
  gauge.font = gaugeFontSize + "px Arial";
  needleBase = size * 0.04;
  needleHeight = needleBase * 3.2;
  needleTwoBase = needleBase*0.7;
  needleTwoHeight = needleHeight * 0.7;

  // get sagitta (height) of arc
  sagitta = gaugeRadius*(1-Math.cos(0.5*((maxAngle-minAngle)*Math.PI/180)));
  // amount to move gauge down to centre based on sagitta, not radius
  centre = (2 * gaugeRadius - sagitta)/2;



  // set colours from CSS
  gauge.fillStyle = "#bbbbbb";
  gauge.strokeStyle = "#bbbbbb";



  // print wind direction, speed and Beaufort description in centre of dial
  gauge.textAlign = "center";

  gauge.fillText(value + " " + units, width / 2, centre+height / 2);

  gauge.fillStyle = cssvar('--needle-colour');
  gauge.strokeStyle = cssvar('--gauge-colour');

  // draw dial


  gauge.translate(width / 2, centre+height / 2); // translate resets (0,0) coords to centre of canvas
  gauge.beginPath();
  gauge.arc(0, 0, gaugeRadius, minAngle * Math.PI / 180, maxAngle * Math.PI / 180);
  // x=0,y=0,radius,start angle 0= 3 o'clock, end angle, <direction>
  gauge.stroke();

  // draw needle
  gauge.beginPath();
  needleAngle = (maxAngle - minAngle) * (value - minValue) / (maxValue - minValue);

  gauge.rotate(-(270 - minAngle) * Math.PI / 180); // how does this work. Rotates to start angle?
  gauge.rotate(needleAngle * Math.PI / 180); //rotate to draw at current deg value
  gauge.translate(0, -gaugeRadius - gauge.lineWidth / 2); // move to radius new 0,0
  gauge.lineTo(needleBase, 0); // draw half of base line
  gauge.lineTo(0, needleHeight); // draw to point
  gauge.lineTo(-needleBase, 0); // draw back to other end of base line
  gauge.fill(); // close fill triangle
  gauge.translate(0, gaugeRadius + gauge.lineWidth / 2); // move back to centre of canvas

gauge.rotate(-needleAngle * Math.PI / 180); //rotate back to start angle
gauge.rotate((270 - minAngle) * Math.PI / 180); // rotate back from start angle to beginning

  gauge.fillStyle = cssvar('--needle-old-colour');

  // needleTwo
  gauge.beginPath();
  needleAngle = (maxAngle - minAngle) * (valueTwo - minValue) / (maxValue - minValue);
  gauge.rotate(-(270 - minAngle) * Math.PI / 180);

  gauge.rotate(needleAngle * Math.PI / 180); //rotate to draw at current deg value
  gauge.translate(0, -gaugeRadius - gauge.lineWidth / 2); // move to radius
  gauge.lineTo(needleTwoBase, 0); // draw half of base line
  gauge.lineTo(0, needleTwoHeight); // draw to point
  gauge.lineTo(-needleTwoBase, 0); // draw back to other end of base line
  gauge.fill(); // close fill triangle

  gauge.translate(0, gaugeRadius + gauge.lineWidth / 2); // move back to centre of canvas

  gauge.rotate(-needleAngle * Math.PI / 180); //rotate back
  gauge.rotate((270 - minAngle) * Math.PI / 180);
  gauge.translate(-width / 2, -(centre+height / 2)); // move back to (0,0) ready for next animation

}

// round gauge with a single line of text (value+units)
function drawRoundGauge(canvasID, value, minAngle = 270, maxAngle = 630, minValue = 0, maxValue = 360, units = '') {
  let canvas = document.getElementById(canvasID);
  //get context
  let gauge = canvas.getContext('2d');
  // get properties of canvas
  width = Number(getComputedStyle(canvas).getPropertyValue("width").slice(0, -2));
  height = Number(getComputedStyle(canvas).getPropertyValue("height").slice(0, -2));

  // to find radius for gauge
  if (width >= height) {
    size = height;
  } else {
    size = width;
  }
  // clear canvas
  gauge.clearRect(0, 0, width, height); // clear canvas

  // adjust dimensions based on canvas dimensions
  gauge.lineWidth = size * 0.04;
  gaugeRadius = (-gauge.lineWidth - size * 0.1) + size / 2;
  gaugeFontSize = size / 10;
  gauge.font = gaugeFontSize + "px Arial";
  needleBase = size * 0.04;
  needleHeight = needleBase * 3.2;

  // set colours from CSS
  gauge.fillStyle = "#bbbbbb";
  gauge.strokeStyle = "#bbbbbb";

  // print wind direction, speed and Beaufort description in centre of dial
  gauge.textAlign = "center";

  gauge.fillText(value + " " + units, width / 2, height / 2);

  gauge.fillStyle = cssvar('--needle-colour');
  gauge.strokeStyle = cssvar('--gauge-colour');

  // draw dial
  gauge.beginPath();

  gauge.translate(width / 2, height / 2);

  gauge.arc(0, 0, gaugeRadius, minAngle * Math.PI / 180, maxAngle * Math.PI / 180);
  // x=0,y=0,radius,start angle 0= 3 o'clock, end angle, <direction>
  gauge.stroke();

  // draw needle
  gauge.beginPath();



  needleAngle = (maxAngle - minAngle) * (value - minValue) / (maxValue - minValue);


  gauge.rotate(-(270 - minAngle) * Math.PI / 180);

  gauge.rotate(needleAngle * Math.PI / 180); //rotate to draw at current deg value
  gauge.translate(0, -gaugeRadius - gauge.lineWidth / 2); // move to radius
  gauge.lineTo(needleBase, 0); // draw half of base line
  gauge.lineTo(0, needleHeight); // draw to point
  gauge.lineTo(-needleBase, 0); // draw back to other end of base line
  gauge.fill(); // close fill triangle

  gauge.translate(0, gaugeRadius + gauge.lineWidth / 2); // move back to centre of canvas

  gauge.rotate(-needleAngle * Math.PI / 180); //rotate back
  gauge.rotate((270 - minAngle) * Math.PI / 180);
  gauge.translate(-width / 2, -height / 2); // move back to (0,0) ready for next animation

}

// initialise canvas to size of parent
async function initCanvas(canvasID) {

  //get canvas
  let canvas = document.getElementById(canvasID);

  //get context
  let ctx = canvas.getContext('2d');

  function parentWidth(elem) {
    return elem.parentElement.clientWidth;
  }

  function parentHeight(elem) {
    return elem.parentElement.clientHeight;
  }

  // gets width and height of parent and sets canvas to match
  parentWidth = parentWidth(document.getElementById(canvasID));
  parentHeight = parentHeight(document.getElementById(canvasID));
  canvasWidth = parentWidth;
  canvasHeight = parentHeight;

  // scale canvas to match screen for sharpness
  scale = window.devicePixelRatio;
  canvas.style.width = canvasWidth + "px";
  canvas.style.height = canvasHeight + "px";
  canvas.width = canvasWidth * scale;
  canvas.height = canvasHeight * scale;
  ctx.scale(scale, scale);
  // now that canvas is initialised it can be drawn on
}

// utility function to fetch the variables from the CSS
function cssvar(name) {
  return getComputedStyle(document.documentElement).getPropertyValue(name);
}
