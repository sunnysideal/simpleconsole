// to be main launch point of console if all requirements are met

  //load scripts in order, waiting to make sure data has arrived
  loadScript('js/suncalc.js')
    .then(() => loadScript('js/paho-mqtt-min.js'))
    .then(() => startConnect())
    .then(() => loadJSON("js/data.json", function(text){
  data = JSON.parse(text);

  // Update all current readings by iterating through all current value keys
  Object.keys(data.current).forEach(item => updateHTML(item,data.current[item]));

  // station lat/lon values for solar stats calculator
  var latitudeDeg = ConvertDMToDD(Number(data.config.latitude_deg),Number(data.config.latitude_minutes),data.config.latitude_heading);
  var longitudeDeg = ConvertDMToDD(Number(data.config.longitude_deg),Number(data.config.longitude_minutes),data.config.longitude_heading);

  // get and display the forecast from OpenWeatherMap
  getForecast(latitudeDeg,longitudeDeg,data.config.owmkey,data.config.consoleunits,Number(data.config.gap));

  // calc and display sunrise and sunset details
  populateSunRiseSet(latitudeDeg,longitudeDeg);

  // baro gauge
  initCanvas('barometer-gauge');
  drawRoundGaugeTwoNeedles('barometer-gauge', Math.round(data.current.barometer),Math.round(data.current.barometer_day_ago), 160, 380, 950, 1050,'hPa');

  initCanvas('sun-chart');
  var today = new Date();
  drawSun('sun-chart',SunCalc.getTimes(today, latitudeDeg, longitudeDeg));
}))
    .catch(() => console.error('Something went wrong.'))




// read values from json
function loadJSON(file,callback) {

    var xobj = new XMLHttpRequest();
        xobj.overrideMimeType("application/json");
    xobj.open('GET', file);
    xobj.onreadystatechange = function () {
          if (xobj.readyState == 4 && xobj.status == "200") {
            // Required use of an anonymous callback as .open will NOT return a value but simply returns undefined in asynchronous mode
            callback(xobj.responseText);
          }
    };
    xobj.send(null);
 }



//Get forecast from Open Weather Map

async function getForecast(latitudeDeg,longitudeDeg,owmkey,units,gap) {

  var owmurl="http://api.openweathermap.org/data/2.5/onecall?lat="+latitudeDeg+"&lon="+longitudeDeg+"&exclude=current,minutely,daily&units="+units+"&appid="+owmkey;

  const response = await fetch(owmurl);

  const forecastJson = await response.json(); //extract JSON from the http response
  forecast = forecastJson['hourly'];  // extract the hourly forecast

  // loop through each of the 3 sets of forecasts allowed in the pane
  for(x=1;x<4;x++){
  // an index to get the correct forecast from the API response
    forecastNumber = 1+(x-1)*gap;

    // get the sunrise/sunset needed to calculate if the forecast time is during day time
    var d = new Date(forecast[forecastNumber]['dt']*1000);
    sunTimes = SunCalc.getTimes(d, latitudeDeg, longitudeDeg);

    // determine if time of forecast is day or night for icon
    if((forecast[forecastNumber]['dt']*1000 > sunTimes.sunrise.getTime()) && (forecast[forecastNumber]['dt']*1000 < sunTimes.sunset.getTime()) )
      owmtime='day';
    else
      owmtime='night';

    // get the hour of the forecast and convert from 24hr to 12hr clock for the weather font clock icon
    forecasthour = d.getHours();
    if (Number(forecasthour) > 12) {
      forecastTime = Number(forecasthour) - 12;
    }
    else if (Number(forecasthour) == 0) {
      forecastTime = 12;
    }
    else {
      forecastTime = Number(forecasthour)
    }



    // Icons from https://erikflowers.github.io/weather-icons/
    updateHTML('forecast-hour-'+x+'-time',"<i class=\"wi wi-time-" + forecastTime + "\"></i>" );
    updateHTML('forecast-hour-'+x+'-icon',"<i class=\"wi wi-owm-"+owmtime+"-"+ forecast[forecastNumber]['weather'][0]['id'] + "\"></i><span class=\"tooltiptext\">"+forecast[forecastNumber]['weather'][0]['description']+"</span>");
    updateHTML('forecast-hour-'+x+'-temp',Math.round(forecast[forecastNumber]['temp']));
    updateHTML('forecast-hour-'+x+'-precip-percent',forecast[forecastNumber]['pop']);
    updateHTML('forecast-hour-'+x+'-wind-dir',"<i class=\"wi wi-wind from-" + forecast[forecastNumber]['wind_deg'] + "-deg\"></i>");
    updateHTML('forecast-hour-'+x+'-wind-spd',Math.round(forecast[forecastNumber]['wind_speed']*10)/10);
  }
}
// end get forecast


// convert lat and long to decimal from format that WeeWx outputs
function ConvertDMToDD(degrees, minutes, direction) {
    var dd = degrees + minutes/60 ;

    if (direction == "S" || direction == "W") {
        dd = dd * -1;
    } // Don't do anything for N or E
    return dd;
}


function populateSunRiseSet(latitude, longitude) {
  today = new Date();
  tomorrow = new Date()
  tomorrow.setDate(tomorrow.getDate() + 1)

  let sunTimes = SunCalc.getTimes(today, latitude, longitude);
  let tomorrowSunTimes = SunCalc.getTimes(tomorrow, latitude, longitude);

  lengthToday = sunTimes.sunset.getTime() - sunTimes.sunrise.getTime(); //in milliseconds
  lengthTomorrow = tomorrowSunTimes.sunset.getTime() - tomorrowSunTimes.sunrise.getTime(); //in milliseconds
  diffDayLength = lengthTomorrow-lengthToday; // in milliseconds


  let sunriseStr = getHumanTimeHHMM(sunTimes.sunrise.getTime() / 1000);
  let sunsetStr = getHumanTimeHHMM(sunTimes.sunset.getTime() / 1000);
  let solarNoonStr = getHumanTimeHHMM(sunTimes.solarNoon.getTime() / 1000);
  let tomorrowSunriseStr = getHumanTimeHHMM(tomorrowSunTimes.sunrise.getTime() / 1000);
  let tomorrowSunsetStr = getHumanTimeHHMM(tomorrowSunTimes.sunset.getTime() / 1000);
  let tomorrowSolarNoonStr = getHumanTimeHHMM(tomorrowSunTimes.solarNoon.getTime() / 1000);
  updateHTML('sunrise_time', sunriseStr);
  updateHTML('sunset_time', sunsetStr);
  updateHTML('solarnoon_time', solarNoonStr);
  updateHTML('tomorrow_sunrise_time', tomorrowSunriseStr);
  updateHTML('tomorrow_sunset_time', tomorrowSunsetStr);
  updateHTML('tomorrow_solarnoon_time', tomorrowSolarNoonStr);
  if(diffDayLength>0){
    updateHTML('solar_tomorrow_text', getHumanTimeMMSS(diffDayLength/1000)+" longer");
  }
  else {
    updateHTML('solar_tomorrow_text', getHumanTimeMMSS(-diffDayLength/1000)+" shorter");
  }
}

// update element HTML
function updateHTML(updateElement, value) {
  if (document.getElementsByClassName(updateElement)) {
    var getClass = document.getElementsByClassName(updateElement);
    for (i = 0; i < getClass.length; i++) {
      getClass[i].innerHTML = value;
    }
  }
} // end updateHTML

function getHumanTimeHHMM(epoch) {
  var d = new Date(epoch * 1000);
  time = pad(d.getHours(), 2) + ":" + pad(d.getMinutes(), 2);

  return time;
} // end getHumanTimeHHMM

function getHumanTimeMMSS(epoch) {
  var d = new Date(epoch * 1000);
  time = pad(d.getMinutes(), 2) + ":" + pad(d.getSeconds(), 2);

  return time;
}

// pad leading zeros in numbers
function pad(n, len) {

  s = n.toString();
  if (s.length < len) {
    s = ('0000000000' + s).slice(-len);
  }

  return s;
}



// round gauge with a single line of text (value+units)
function drawRoundGaugeTwoNeedles(canvasID, value, valueTwo, minAngle = 270, maxAngle = 630, minValue = 0, maxValue = 360, units = '') {
  let canvas = document.getElementById(canvasID);
  //get context
  let gauge = canvas.getContext('2d');
  // get properties of canvas
  width = Number(getComputedStyle(canvas).getPropertyValue("width").slice(0, -2));
  height = Number(getComputedStyle(canvas).getPropertyValue("height").slice(0, -2));
  // to find radius for gauge
  if (width >= height) {
    size = height;
  } else {
    size = width;
  }

  // clear canvas
  gauge.clearRect(0, 0, width, height); // clear canvas

  // adjust dimensions based on canvas dimensions
  gauge.lineWidth = size * 0.04;
  gaugeRadius = (-gauge.lineWidth - size * 0.1) + size / 2;
  gaugeFontSize = size / 10;
  gauge.font = gaugeFontSize + "px Arial";
  needleBase = size * 0.04;
  needleHeight = needleBase * 3.2;
  needleTwoBase = needleBase*0.7;
  needleTwoHeight = needleHeight * 0.7;

  // get sagitta (height) of arc
  sagitta = gaugeRadius*(1-Math.cos(0.5*((maxAngle-minAngle)*Math.PI/180)));
  // amount to move gauge down to centre based on sagitta, not radius
  centre = (2 * gaugeRadius - sagitta)/2;



  // set colours from CSS
  gauge.fillStyle = "#bbbbbb";
  gauge.strokeStyle = "#bbbbbb";



  // print wind direction, speed and Beaufort description in centre of dial
  gauge.textAlign = "center";

  gauge.fillText(value + " " + units, width / 2, centre+height / 2);

  gauge.fillStyle = cssvar('--needle-colour');
  gauge.strokeStyle = cssvar('--gauge-colour');

  // draw dial


  gauge.translate(width / 2, centre+height / 2); // translate resets (0,0) coords to centre of canvas
  gauge.beginPath();
  gauge.arc(0, 0, gaugeRadius, minAngle * Math.PI / 180, maxAngle * Math.PI / 180);
  // x=0,y=0,radius,start angle 0= 3 o'clock, end angle, <direction>
  gauge.stroke();

  // draw needle
  gauge.beginPath();
  needleAngle = (maxAngle - minAngle) * (value - minValue) / (maxValue - minValue);

  gauge.rotate(-(270 - minAngle) * Math.PI / 180); // how does this work. Rotates to start angle?
  gauge.rotate(needleAngle * Math.PI / 180); //rotate to draw at current deg value
  gauge.translate(0, -gaugeRadius - gauge.lineWidth / 2); // move to radius new 0,0
  gauge.lineTo(needleBase, 0); // draw half of base line
  gauge.lineTo(0, needleHeight); // draw to point
  gauge.lineTo(-needleBase, 0); // draw back to other end of base line
  gauge.fill(); // close fill triangle
  gauge.translate(0, gaugeRadius + gauge.lineWidth / 2); // move back to centre of canvas

gauge.rotate(-needleAngle * Math.PI / 180); //rotate back to start angle
gauge.rotate((270 - minAngle) * Math.PI / 180); // rotate back from start angle to beginning

  gauge.fillStyle = cssvar('--needle-old-colour');

  // needleTwo
  gauge.beginPath();
  needleAngle = (maxAngle - minAngle) * (valueTwo - minValue) / (maxValue - minValue);
  gauge.rotate(-(270 - minAngle) * Math.PI / 180);

  gauge.rotate(needleAngle * Math.PI / 180); //rotate to draw at current deg value
  gauge.translate(0, -gaugeRadius - gauge.lineWidth / 2); // move to radius
  gauge.lineTo(needleTwoBase, 0); // draw half of base line
  gauge.lineTo(0, needleTwoHeight); // draw to point
  gauge.lineTo(-needleTwoBase, 0); // draw back to other end of base line
  gauge.fill(); // close fill triangle

  gauge.translate(0, gaugeRadius + gauge.lineWidth / 2); // move back to centre of canvas

  gauge.rotate(-needleAngle * Math.PI / 180); //rotate back
  gauge.rotate((270 - minAngle) * Math.PI / 180);
  gauge.translate(-width / 2, -(centre+height / 2)); // move back to (0,0) ready for next animation

}

// round gauge with a single line of text (value+units)
function drawRoundGauge(canvasID, value, minAngle = 270, maxAngle = 630, minValue = 0, maxValue = 360, units = '') {
  let canvas = document.getElementById(canvasID);
  //get context
  let gauge = canvas.getContext('2d');
  // get properties of canvas
  width = Number(getComputedStyle(canvas).getPropertyValue("width").slice(0, -2));
  height = Number(getComputedStyle(canvas).getPropertyValue("height").slice(0, -2));

  // to find radius for gauge
  if (width >= height) {
    size = height;
  } else {
    size = width;
  }
  // clear canvas
  gauge.clearRect(0, 0, width, height); // clear canvas

  // adjust dimensions based on canvas dimensions
  gauge.lineWidth = size * 0.04;
  gaugeRadius = (-gauge.lineWidth - size * 0.1) + size / 2;
  gaugeFontSize = size / 10;
  gauge.font = gaugeFontSize + "px Arial";
  needleBase = size * 0.04;
  needleHeight = needleBase * 3.2;

  // set colours from CSS
  gauge.fillStyle = "#bbbbbb";
  gauge.strokeStyle = "#bbbbbb";

  // print wind direction, speed and Beaufort description in centre of dial
  gauge.textAlign = "center";

  gauge.fillText(value + " " + units, width / 2, height / 2);

  gauge.fillStyle = cssvar('--needle-colour');
  gauge.strokeStyle = cssvar('--gauge-colour');

  // draw dial
  gauge.beginPath();

  gauge.translate(width / 2, height / 2);

  gauge.arc(0, 0, gaugeRadius, minAngle * Math.PI / 180, maxAngle * Math.PI / 180);
  // x=0,y=0,radius,start angle 0= 3 o'clock, end angle, <direction>
  gauge.stroke();

  // draw needle
  gauge.beginPath();



  needleAngle = (maxAngle - minAngle) * (value - minValue) / (maxValue - minValue);


  gauge.rotate(-(270 - minAngle) * Math.PI / 180);

  gauge.rotate(needleAngle * Math.PI / 180); //rotate to draw at current deg value
  gauge.translate(0, -gaugeRadius - gauge.lineWidth / 2); // move to radius
  gauge.lineTo(needleBase, 0); // draw half of base line
  gauge.lineTo(0, needleHeight); // draw to point
  gauge.lineTo(-needleBase, 0); // draw back to other end of base line
  gauge.fill(); // close fill triangle

  gauge.translate(0, gaugeRadius + gauge.lineWidth / 2); // move back to centre of canvas

  gauge.rotate(-needleAngle * Math.PI / 180); //rotate back
  gauge.rotate((270 - minAngle) * Math.PI / 180);
  gauge.translate(-width / 2, -height / 2); // move back to (0,0) ready for next animation

}

// initialise canvas to size of parent
async function initCanvas(canvasID) {

  //get canvas
  let canvas = document.getElementById(canvasID);

  //get context
  let ctx = canvas.getContext('2d');

  function parentWidth(elem) {
    return elem.parentElement.clientWidth;
  }

  function parentHeight(elem) {
    return elem.parentElement.clientHeight;
  }

  // gets width and height of parent and sets canvas to match
  parentWidth = parentWidth(document.getElementById(canvasID));
  parentHeight = parentHeight(document.getElementById(canvasID));
  canvasWidth = parentWidth;
  canvasHeight = parentHeight;

  // scale canvas to match screen for sharpness
  scale = window.devicePixelRatio;
  canvas.style.width = canvasWidth + "px";
  canvas.style.height = canvasHeight + "px";
  canvas.width = canvasWidth * scale;
  canvas.height = canvasHeight * scale;
  ctx.scale(scale, scale);
  // now that canvas is initialised it can be drawn on
}

// utility function to fetch the variables from the CSS
function cssvar(name) {
  return getComputedStyle(document.documentElement).getPropertyValue(name);
}

// function to load scripts in correct order
//const loadScript = src => {
function loadScript(src) {
  return new Promise((resolve, reject) => {
    const script = document.createElement('script')
    script.type = 'text/javascript'
    script.onload = resolve
    script.onerror = reject
    script.src = src
    document.head.append(script)
  })
}

function startConnect() {
    // Generate a random client ID
    clientID = "clientID-" + parseInt(Math.random() * 100);

    // Fetch the hostname/IP address and port number from the form
    host = "test.mosquitto.org";
    port = "8080";

    // Print output for the user in the messages div
    console.log( 'Connecting to: ', host ,' on port: ', port );

    // Initialize new Paho client connection
    client = new Paho.MQTT.Client(host, Number(port), clientID);

    // Set callback handlers
    client.onConnectionLost = onConnectionLost;
    client.onMessageArrived = onMessageArrived;

    // Connect the client, if successful, call onConnect function
    client.connect({
        'onSuccess': onConnect,
        'useSSL': false
    });
}

// Called when the client connects
function onConnect() {
    // Fetch the MQTT topic from the form
    topic = "sunnysideweather/loop";

    // Print output for the user in the messages div
    console.log('Subscribing to: ',topic);

    // Subscribe to the requested topic
    client.subscribe(topic);
}

// Called when the client loses its connection
function onConnectionLost(responseObject) {
    console.log("onConnectionLost: Connection Lost");
    if (responseObject.errorCode !== 0) {
        console.log("onConnectionLost: " + responseObject.errorMessage);
    }
}

// Called when a message arrives
function onMessageArrived(message) {
// check if archive to update all...

// also, if time goes above midnight run sun calc
// html5 canvas for sun transit?

mqttData = JSON.parse(message.payloadString);
updateHTML('air_temperature',Math.round(10*mqttData.outTemp_C)/10);
updateHTML('obs_time',getHumanTimeHHMM(mqttData.dateTime));
}

// Called when the disconnection button is pressed
function startDisconnect() {
    client.disconnect();
}

//******************************************************
// draw sun path chart
//******************************************************

function drawSun(canvasID, sunTimes) {

// extract times for the calculation
  sunrise = sunTimes.sunrise.getTime();
  sunset = sunTimes.sunset.getTime();
  transit = sunTimes.solarNoon.getTime();
  var currentTime = new Date();

  let canvas = document.getElementById(canvasID);
  //get context
  let gauge = canvas.getContext('2d');
  // get properties of canvas
  width = Number(getComputedStyle(canvas).getPropertyValue("width").slice(0, -2));
  height = Number(getComputedStyle(canvas).getPropertyValue("height").slice(0, -2));

  // clear canvas
  gauge.clearRect(0, 0, width, height); // clear canvas

  // adjust dimensions based on canvas dimensions
  gauge.lineWidth = width * 0.001;

  // set colours
  gauge.fillStyle = "#bbbbbb";
  gauge.strokeStyle = "#FFA500";

  // draw dial
  gauge.setLineDash([1, 3]);
  gauge.beginPath();

  gauge.beginPath();

   gauge.moveTo(width*0.05, height*0.95);  // start point left side of canvas
   gauge.quadraticCurveTo(
       width/4, height*0.05,     // controls point sets slope out from start and into center
       width/2,height*0.05              // center point
   );
   gauge.quadraticCurveTo(
       3*width/4, height*0.05,     // control point sets slope out from center and into last point
       width*0.95, height *0.95          // last point
   );

  gauge.stroke();



  // start to draw sun
  // remove dashes
  gauge.setLineDash([]);
  gauge.lineWidth = width * 0.003;
  gauge.strokeStyle = "#FFD700";
  timeOfDay="dark";
  console.log(currentTime.getTime() - sunrise);
  console.log(currentTime.getTime() - transit);
  console.log(sunrise," ",currentTime.getTime(), " ",transit," ",sunset);
if(currentTime.getTime() > sunrise && currentTime.getTime() < transit){

  timeOfDay = "am";
  percentage = (currentTime - sunrise)/(transit-sunrise);
  console.log("am ",percentage);
  coords = getQuadraticXY(percentage, width*0.05, height*0.95,width/4, height*0.05, width/2,height*0.05);
}
else if (currentTime>transit && currentTime < sunset){

  timeOfDay = "pm";
  percentage = (currentTime - transit)/(sunset-transit);


  coords = getQuadraticXY(percentage, width/2,height*0.05,3*width/4, height*0.05, width*0.95, height *0.95 );
}
if(timeOfDay != "dark"){


pointX = coords.x;
pointY = coords.y;

gauge.beginPath();
// draw circle body of sun
gauge.arc(pointX, pointY, 3, 0, Math.PI * 2);
gauge.fill();

// reset (0,0) to centre of 'sun'
gauge.translate(pointX,pointY);
for(var y=0;y<8;y++){
  gauge.moveTo(0,5);
  gauge.lineTo(0,9);
  gauge.stroke();
  gauge.rotate(Math.PI/4);
}
gauge.translate(-pointX,-pointY);

}}

function getQuadraticXY(t, sx, sy, cp1x, cp1y, ex, ey) {
  return {
    x: (1-t) * (1-t) * sx + 2 * (1-t) * t * cp1x + t * t * ex,
    y: (1-t) * (1-t) * sy + 2 * (1-t) * t * cp1y + t * t * ey
  };
}
